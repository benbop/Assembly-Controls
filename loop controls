IDEAL
MODEL small
STACK 100h
DATASEG
; --------------------------

Y dw 100 ; of charchter
X dw 100 ; of charchter
TIME_AUX DB 0 ; for waiting in between frames 
PressFlag db 0 ; press flag
SnakeBody dw 5	; body of charcter
Xapple dw 80 ; y of apple
yapple dw 80 ; x of apple
Random_x dw 50 ; my rnds
Random_y dw 50 ; my rnds
Speed dw 5 ; speed of snake
Player_Score DB 48 ; ascii value of 0


; --------------------------
CODESEG

proc set_cursor
MOV AH, 02h
    MOV BH, 0
    MOV DH, 1 ; Adjust row for the score display
    MOV DL, 1 ; Adjust column for the score display
    INT 10h
	RET
	ENDP set_cursor
PROC Score
    mov ah, 09h  ; Display character function
	mov bh, 0    ; Page number
	mov cx, 1    ; Number of times to display character
	mov al, [Player_Score]  ; Character to display
    mov bl, 1    ; Attribute (text color)
    int 10h
    MOV AH, 02h
    MOV BH, 0
    MOV DH, 1 ; Adjust row for the score display
    MOV DL, 1 ; Adjust column for the score display
    INT 10h
    RET
ENDP Score

  
PROC moves

    MOV AH, 01h       ; Function 01h - Check for Key Press
    INT 16h
    JZ exit_moves     ; Jump if ZF is set (no key pressed)

    MOV AH, 00h       ; Function 00h - Read Key Stroke
    INT 16h

    ; Check if AH contains 'W' (ASCII value 87)
    CMP AL, 'w'
	je w_pressed
    
    ; Check if AH contains 'S' (ASCII value 83)
    
    ; Check if AH contains 'D' (ASCII value 68)
    CMP AL, 'd'
    je d_pressed
    ; Check if AH contains 'A' (ASCII value 65)
    CMP AL, 'a'
    je a_pressed
    ; Check if AH contains '1B' (Escape key)
    CMP AL, 's'
    JMP s_pressed

exit_moves:

    RET

ENDP moves

PROC w_pressed
    mov [PressFlag], 1
	mov cx , [Speed]
	SUB [Y], cx
	
	

    CHECK_TIME1:         ;time checking loop
    MOV AH,2Ch 					 ;get the system time
    INT 21h 			 ;is the current time equal to the previous one(TIME_AUX)?
    CMP DL,[TIME_AUX] 			 ;is the current time equal to the previous one(TIME_AUX)?

    JE CHECK_TIME1
    MOV [TIME_AUX],DL 
	
    CALL draw
	
	call moves
	CMP [PressFlag],1
    je w_pressed
    
	RET
ENDP w_pressed

PROC d_pressed
    mov [PressFlag], 2
	mov cx , [Speed]
	ADD [X], cx
	

    CHECK_TIME2:          ;time checking loop
    MOV AH,2Ch 					 ;get the system time
    INT 21h 			 ;is the current time equal to the previous one(TIME_AUX)?
    CMP DL,[TIME_AUX] 			 ;is the current time equal to the previous one(TIME_AUX)?

    JE CHECK_TIME2
    MOV [TIME_AUX],DL 
	
    CALL draw
	
	call moves
	cmp [PressFlag],2
    je d_pressed
	ret
ENDP d_pressed

PROC a_pressed
    mov [PressFlag], 3
	mov cx , [Speed]
	SUB [X], cx
	

    CHECK_TIME3:           ;time checking loop
    MOV AH,2Ch 					 ;get the system time
    INT 21h 			 ;is the current time equal to the previous one(TIME_AUX)?
    CMP DL,[TIME_AUX] 			 ;is the current time equal to the previous one(TIME_AUX)?
	
    JE CHECK_TIME3
    MOV [TIME_AUX],DL 
	
    CALL draw
	
	call moves
	CMP [PressFlag],3
    je a_pressed
	ret
ENDP a_pressed

PROC s_pressed
    mov [PressFlag], 4
	mov cx , [Speed]
	ADD [Y], cx
    
    CHECK_TIME4:           ;time checking loop
    MOV AH,2Ch 					 ;get the system time
    INT 21h 			 ;is the current time equal to the previous one(TIME_AUX)?
    CMP DL,[TIME_AUX] 			 ;is the current time equal to the previous one(TIME_AUX)?

    JE CHECK_TIME4
	
    MOV [TIME_AUX],DL 
    CALL draw
	
	call moves
	
	CMP [PressFlag],4
    je s_pressed
	RET
ENDP s_pressed
 



PROC draw


    MOV AX, 0C07h     ; Function 0Ch, Set Pixel Color
    MOV BH, 0         ; Page number (usually 0 in mode 13h)

    ; Draw the gray border
    MOV CX, 40         ; X-coordinate of the left border
    MOV DX, 49         ; Y-coordinate of the top border
    MOV SI, 0
    MOV DI, 0
    MOV AL, 8          ; Color for gray pixels

    draw_row_loop_border:
        draw_pixel_loop_border:
            INC CX
            INC DI

            INT 10h
            CMP DI, 240       ; Width of the border
            JNE draw_pixel_loop_border

            SUB CX, 240        ; Reset X-coordinate to start
            MOV DI, 0
            INC DX
            INC SI

            CMP SI, 150        ; Height of the border
            JNE draw_row_loop_border

    
   
    
    MOV AX, 0C07h     ; Function 0Ch, Set Pixel Color
    MOV BH, 0         ; Page number (usually 0 in mode 13h)
    
    ; Draw the apple
    MOV CX, [Xapple]  ; X-coordinate of the apple
    MOV DX, [yapple]  ; Y-coordinate of the apple
    MOV SI, 0
    MOV DI, 0
    MOV AL, 4          ; Color (choose a color different from the snake)

    draw_row_loop_apple:
        draw_pixel_loop_apple:
            INC CX
            INC DI
            
            INT 10h
            CMP DI, [SnakeBody]  ; size of the apple must be the same size of the snake for collison to work
            JNE draw_pixel_loop_apple
            
            SUB CX, [SnakeBody]  ; without this, the apple is not drawing up; it's drawing to the side
            MOV DI, 0
            INC DX
            INC SI
            
            CMP SI, [SnakeBody];  size of the apple must be the same size of the snake for collison to work
            JNE draw_row_loop_apple
	
    ; Draw the snake
    MOV CX, [X]       ; X-coordinate of the snake head
    MOV DX, [Y]       ; Y-coordinate of the snake head
    MOV SI, 0
    MOV DI, 0
    MOV AL, 2         ; Color green (you can choose a different color)

    draw_row_loop:
        draw_pixel_loop:
            INC CX
            INC DI
            
            INT 10h
            CMP DI, [SnakeBody] 
            JNE draw_pixel_loop
            
            SUB CX, [SnakeBody]
            MOV DI, 0
            INC DX
            INC SI
            
            CMP SI, [SnakeBody] 
            JNE draw_row_loop

CALL check_collision
		

    RET
ENDP draw



 PROC check_collision ; checks for collison with snake
 

    mov ax, [yapple]
	
    cmp ax, [Y]
    jne skip_draw_apple

    mov bx, [Xapple]
    cmp bx, [X]
    jne skip_draw_apple

    call rnd_x ; moves snake to x coords
    mov dx, [Random_x]
	ADD DX , 40 ; settings borders of the screen decided on 90 so game is centerd
    mov [Xapple], dx
	Inc [Player_Score]
	call set_cursor
	call Score
	
	call rnd_y ; moves snake to y coords
	mov dx , [Random_y]
	ADD DX , 50 ; settings borders of the screen has to be at least 50 so no artifacts!!!
	mov [yapple], DX
	
    
    RET

skip_draw_apple:
    RET
	
ENDP check_collision ; hitbox code

		Proc rnd_x
		
		checkForFiveX:  ; checks if the rnd_x int is divisible by five
    mov ah, 2ch ; get time method
    int 21h ; call for clock
	add  DL, DL
	
    mov [byte ptr Random_x], dl
		mov dx,0
		mov ax , [Random_x]
		div [Speed] ; divide by speed of snake
	cmp DX,0
	
	JNE checkForFiveX
	
    ret
ENDP rnd_x

Proc rnd_y

checkForFiveY:  ; checks if the rnd_x int is divisible by five

		mov ah, 2ch
		int 21h
		mov bx , [Random_y]
		mov [byte ptr Random_y], dl
		
		mov dx,0
			mov ax , [Random_y]
			div [Speed] ; divide by speed of snake
			cmp DX,0
		JNE checkForFiveY
		
		ENDP rnd_y
		
PROC game_logic

    CHECK_TIME:                      ;time checking loop
        MOV AH, 2Ch                  ;get the system time
        INT 21h                      ;is the current time equal to the previous one(TIME_AUX)?
        CMP DL, [TIME_AUX]           ;is the current time equal to the previous one(TIME_AUX)?
		
        JE CHECK_TIME                ;if it is the same, check again

        ; If it reaches this point, it's because the time has passed
        MOV [TIME_AUX], DL           ;update time
        
		CALL moves
		
        
		
        

        RET

ENDP game_logic



start:
    MOV AX, @data
    MOV DS, AX


    MOV AX, 13h
    INT 10h ; Set video mode 13h (320x200 pixels, 256 colors)
	
	
    game_loop:
	CALL game_logic
    CALL draw           ; Draw the game screen
    
	 
	
	
    JMP game_loop

exit:
    MOV AX, 4C00h
    INT 21h

END start
